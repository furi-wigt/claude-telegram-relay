/**
 * Claude Telegram Relay — Configure PM2 (Cross-platform)
 *
 * Generates and manages PM2 ecosystem config for all services.
 * Supports cron scheduling for periodic jobs.
 *
 * Usage: bun run setup/configure-pm2.ts [--service relay|checkin|briefing|summary|watchdog|all]
 */

import { writeFile } from "fs/promises";
import { existsSync, mkdirSync } from "fs";
import { join, dirname } from "path";
import { homedir } from "os";

const PROJECT_ROOT = dirname(import.meta.dir);
const HOME = homedir();
const LOGS_DIR = join(PROJECT_ROOT, "logs");
const ECOSYSTEM_FILE = join(PROJECT_ROOT, "ecosystem.config.js");

// Colors
const green = (s: string) => `\x1b[32m${s}\x1b[0m`;
const red = (s: string) => `\x1b[31m${s}\x1b[0m`;
const yellow = (s: string) => `\x1b[33m${s}\x1b[0m`;
const cyan = (s: string) => `\x1b[36m${s}\x1b[0m`;
const bold = (s: string) => `\x1b[1m${s}\x1b[0m`;
const dim = (s: string) => `\x1b[2m${s}\x1b[0m`;

const PASS = green("✓");
const FAIL = red("✗");

// Find bun path
async function findBun(): Promise<string> {
  const candidates = [
    join(HOME, ".bun", "bin", "bun"),
    "/usr/local/bin/bun",
    "/opt/homebrew/bin/bun",
  ];
  for (const p of candidates) {
    if (existsSync(p)) return p;
  }
  // Fallback: which bun
  const proc = Bun.spawn(["which", "bun"], { stdout: "pipe" });
  const out = await new Response(proc.stdout).text();
  return out.trim() || "bun";
}

interface ServiceConfig {
  name: string;
  script: string;
  cron?: string; // PM2 cron expression
  autorestart: boolean;
  watch: boolean;
  instances: number;
  description: string;
}

const SERVICES: Record<string, ServiceConfig> = {
  relay: {
    name: "telegram-relay",
    script: "src/relay.ts",
    autorestart: true,
    watch: false,
    instances: 1,
    description: "Main bot (always running, restarts on crash)",
  },
  checkin: {
    name: "smart-checkin",
    script: "examples/smart-checkin.ts",
    cron: "*/30 * * * *", // Every 30 minutes
    autorestart: false,
    watch: false,
    instances: 1,
    description: "Smart check-ins (every 30 minutes during work hours)",
  },
  briefing: {
    name: "morning-briefing",
    script: "examples/morning-briefing-etf.ts",
    cron: "0 7 * * *", // Daily at 7:00 AM
    autorestart: false,
    watch: false,
    instances: 1,
    description: "ETF morning briefing (daily at 7am)",
  },
  summary: {
    name: "night-summary",
    script: "examples/night-summary.ts",
    cron: "0 23 * * *", // Daily at 11:00 PM
    autorestart: false,
    watch: false,
    instances: 1,
    description: "Night summary (daily at 11pm)",
  },
  watchdog: {
    name: "watchdog",
    script: "setup/watchdog.ts",
    cron: "15 0,6,8,12,18,23 * * *", // 6 times daily at specific hours
    autorestart: false,
    watch: false,
    instances: 1,
    description: "Watchdog (monitors all jobs, runs 6x daily)",
  },
};

function generateEcosystem(services: ServiceConfig[], bunPath: string): string {
  const apps = services.map((svc) => {
    const app: Record<string, any> = {
      name: svc.name,
      script: svc.script,
      interpreter: bunPath,
      cwd: PROJECT_ROOT,
      instances: svc.instances,
      autorestart: svc.autorestart,
      watch: svc.watch,
      max_memory_restart: "500M",
      env: {
        NODE_ENV: "production",
        PATH: `${HOME}/.bun/bin:/usr/local/bin:/usr/bin:/bin`,
        HOME: HOME,
      },
      error_file: join(LOGS_DIR, `${svc.name}.error.log`),
      out_file: join(LOGS_DIR, `${svc.name}.log`),
      log_date_format: "YYYY-MM-DD HH:mm:ss Z",
    };

    // Add cron scheduling if defined
    if (svc.cron) {
      app.cron_restart = svc.cron;
      app.autorestart = false; // Cron jobs shouldn't autorestart
    }

    return app;
  });

  return `// PM2 Ecosystem Configuration
// Generated by setup/configure-pm2.ts
// DO NOT EDIT MANUALLY - Run: bun run setup/configure-pm2.ts

module.exports = {
  apps: ${JSON.stringify(apps, null, 2)}
};
`;
}

async function checkPM2Installed(): Promise<boolean> {
  try {
    const proc = Bun.spawn(["npx", "pm2", "-v"], {
      stdout: "pipe",
      stderr: "pipe",
    });
    const code = await proc.exited;
    return code === 0;
  } catch {
    return false;
  }
}

async function installPM2(): Promise<boolean> {
  console.log(`  ${cyan("Installing PM2...")}`);
  try {
    const proc = Bun.spawn(["npm", "install", "-g", "pm2"], {
      stdout: "pipe",
      stderr: "pipe",
    });
    const code = await proc.exited;
    if (code === 0) {
      console.log(`  ${PASS} PM2 installed successfully`);
      return true;
    }
    console.log(`  ${FAIL} Failed to install PM2`);
    return false;
  } catch (error) {
    console.error(`  ${FAIL} Error installing PM2:`, error);
    return false;
  }
}

async function setupPM2Startup(): Promise<void> {
  console.log(`  ${cyan("Setting up PM2 startup script...")}`);
  try {
    // Generate startup script
    const proc = Bun.spawn(["npx", "pm2", "startup"], {
      stdout: "pipe",
      stderr: "pipe",
    });
    const output = await new Response(proc.stdout).text();
    const code = await proc.exited;

    if (code === 0) {
      console.log(`  ${PASS} PM2 startup configured`);
      console.log(`  ${dim("Run the command above if prompted")}`);
    } else {
      console.log(`  ${yellow("⚠")} PM2 startup may require manual setup`);
      console.log(dim(`      Output: ${output}`));
    }
  } catch (error) {
    console.log(`  ${yellow("⚠")} Could not configure PM2 startup`);
  }
}

async function startServices(
  serviceNames: string[],
  bunPath: string
): Promise<boolean> {
  const services = serviceNames.map((name) => SERVICES[name]);
  const ecosystemContent = generateEcosystem(services, bunPath);

  // Write ecosystem config
  await writeFile(ECOSYSTEM_FILE, ecosystemContent);
  console.log(`  ${PASS} Generated ecosystem.config.js`);

  // Stop all processes first (ignore errors)
  try {
    await Bun.spawn(["npx", "pm2", "delete", "all"], {
      stdout: "pipe",
      stderr: "pipe",
    }).exited;
  } catch {
    // Ignore - processes might not exist
  }

  // Start services using ecosystem file
  console.log(`  ${cyan("Starting services with PM2...")}`);
  const proc = Bun.spawn(["npx", "pm2", "start", ECOSYSTEM_FILE], {
    stdout: "pipe",
    stderr: "pipe",
  });
  const stderr = await new Response(proc.stderr).text();
  const code = await proc.exited;

  if (code !== 0) {
    console.log(`  ${FAIL} Failed to start services: ${stderr.trim()}`);
    return false;
  }

  // Save PM2 process list
  const saveProc = Bun.spawn(["npx", "pm2", "save"], {
    stdout: "pipe",
    stderr: "pipe",
  });
  await saveProc.exited;

  console.log(`  ${PASS} Services started and saved`);
  return true;
}

async function showStatus(): Promise<void> {
  console.log("");
  console.log(bold("  PM2 Service Status:"));
  console.log("");

  const proc = Bun.spawn(["npx", "pm2", "status"], {
    stdout: "inherit",
    stderr: "inherit",
  });
  await proc.exited;
}

async function main() {
  console.log("");
  console.log(bold("  Configure PM2 Services"));
  console.log("");

  // Ensure logs directory exists
  if (!existsSync(LOGS_DIR)) {
    mkdirSync(LOGS_DIR, { recursive: true });
  }

  // Check if PM2 is installed
  const pm2Installed = await checkPM2Installed();
  if (!pm2Installed) {
    console.log(`  ${yellow("⚠")} PM2 not found. Installing...`);
    const installed = await installPM2();
    if (!installed) {
      console.log("");
      console.log(`  ${red("Error:")} Could not install PM2`);
      console.log(`  ${dim("Try manually:")}  npm install -g pm2`);
      process.exit(1);
    }
  } else {
    console.log(`  ${PASS} PM2 is installed`);
  }

  const bunPath = await findBun();
  console.log(dim(`  Bun: ${bunPath}`));
  console.log(dim(`  Project: ${PROJECT_ROOT}`));
  console.log("");

  // Parse --service flag
  const args = process.argv.slice(2);
  const serviceIdx = args.indexOf("--service");
  const serviceArg = serviceIdx !== -1 ? args[serviceIdx + 1] : "relay";

  const toInstall =
    serviceArg === "all" ? Object.keys(SERVICES) : [serviceArg];

  // Validate service names
  for (const name of toInstall) {
    if (!SERVICES[name]) {
      console.log(`  ${FAIL} Unknown service: ${name}`);
      console.log(
        `      ${dim("Available: relay, checkin, briefing, summary, watchdog, all")}`
      );
      process.exit(1);
    }
  }

  // Show what will be installed
  console.log(bold("  Services to configure:"));
  for (const name of toInstall) {
    const config = SERVICES[name];
    const scheduleInfo = config.cron
      ? `(cron: ${config.cron})`
      : "(always running)";
    console.log(`    • ${config.name} ${dim(scheduleInfo)}`);
    console.log(`      ${dim(config.description)}`);
  }
  console.log("");

  // Start services
  const success = await startServices(toInstall, bunPath);

  if (!success) {
    console.log("");
    console.log(`  ${red("Setup failed!")}`);
    process.exit(1);
  }

  // Setup PM2 startup (optional)
  await setupPM2Startup();

  // Show status
  await showStatus();

  console.log("");
  console.log(`  ${green("Done!")} Services are running with PM2.`);
  console.log("");
  console.log(`  ${dim("Useful commands:")}`);
  console.log(`    npx pm2 status              ${dim("# View all services")}`);
  console.log(
    `    npx pm2 logs telegram-relay ${dim("# View relay logs")}`
  );
  console.log(`    npx pm2 logs                ${dim("# View all logs")}`);
  console.log(
    `    npx pm2 restart telegram-relay ${dim("# Restart a service")}`
  );
  console.log(
    `    npx pm2 stop all            ${dim("# Stop all services")}`
  );
  console.log(
    `    npx pm2 delete all          ${dim("# Remove all services")}`
  );
  console.log(
    `    npx pm2 monit               ${dim("# Real-time monitoring")}`
  );
  console.log("");
}

main().catch((err) => {
  console.error(`\n  ${red("Error:")} ${err.message}`);
  process.exit(1);
});
